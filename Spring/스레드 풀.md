# 스레드 풀

## Thread per request model

- 서버 API에 요청이 들어오면 이 요청을 처리하는 여러 방식 중 한 가지 방식이다.
- request마다 thread를 하나하나씩 할당을 해 하나의 request는 하나의 thread가 처리할 수 있도록 한다.

### 서버에 들어오는 요청마다 스레드를 새로 만들어서 처리하고 처리가 끝난 스레드는 버리는 식으로 동작한다면?

- 스레드 생성에 소요되는 시간 때문에 요청 처리가 더 오래 걸림
    - 커널 레벨에서 생성되기 때문에 일반적인 CPU 연산작업보다 오래 걸린다.
- 처리 속도보다 더 빠르게 요청이 늘어나면
    - 스레드가 계속 생성(스레드 수 증가) → 컨텍스트 스위칭이 더 자주 발생
        
        → CPU 오버헤드 증가로 CPU time 낭비
        
        → 어느 순간 서버 전체가 응답 불가능 상태에 빠진다.
        
    - 스레드 수가 증가하면 메모리가 점점 고갈된다. (스레드가 점유하는 메모리가 있기 때문)

## 스레드 풀의 개념과 특징

### 동작방식

- 정해진 갯수만큼 미리 스레드를 만들어 놓는다.
- 서버 API에 요청이 들어오면 스레드 풀 내부적으로 관리하는 큐에 들어온다.
- 일이 없는 스레드에 요청이 할당되어 처리한다.
- 처리가 끝나면 그 스레드는 스레드 풀로 들어온다.

### 특징

- 스레드 풀은 미리 스레드를 여러 개 만들어 놓고 재사용한다.
    - 스레드 생성 시간 절약
- 제한된 개수의 스레드를 운용
    - 스레드가 무제한으로 생성되는 것을 방지한다.

### 스레드 풀의 사례 : 여러 작업을 동시에 처리해야 할 때

- thread per request 모델
- task를 subtask로 나뉘어서 동시에 처리
- 순서 상관없이 동시 실행이 가능한 task 처리

## 스레드 풀 사용 팁

### 스레드 풀에 몇 개의 스레드를 만들어 두는 게 절절한가?

- CPU의 코어 개수와 task의 성향에 따라 다르다.
- CPU-bound task라면 코어 개수 만큼 혹은 그 보다 몇 개 더 많은 정도가 좋다.
- I/O-bound task라면 코어 개수보다 2배? 3배? 경험적으로 찾아야함. 코어 개수보다는 많게 하는게 좋다.

### 스레드 풀의 큐 사이즈 확인하기

- 스레드 풀에서 실행될 task 개수에 제한이 없다면 스레드 풀의 큐가 사이즈 제한이 있는지 꼭 확인하기
- 요청이 많이 들어와서 스레드 풀의 모든 스레드가 처리 중일 때 큐에 요청들이 계속 쌓이게 된다.
    - 잠재적으로 메모리를 고갈 시킬 수 있는 위험요인에 될 수 있다.
    - 큐 사이즈에 제한을 두고 그 이상의 요청은 버리더라도 전체 시스템에 문제가 되는 상황이 발생하지 않도록 해야한다.