# 코루틴

## 선수지식

### 동기와 비동기

- 동기 : 어떤 요청을 보낸 뒤, 그 요청의 결과값을 얻기까지 작업을 멈추는 것
- 비동기 : 어떤 요청을 보낸 뒤, 그 요청의 결과값이 오기까지 멈추지 않고 또 다른 일을 수행하는 것

### 쓰레드와 프로세스

- Process : 보조기억장치의 ‘프로그램’이 메모리 상으로 적재되어 실행되면 ‘프로세스’가 된다.
- Thread : 같은 Process 내에서 실행되는 여러 작업(흐름)의 단

process는 독립된 메모리 영역인 ‘Heap’을 할당받는다.

Thread는 Process 하위에 종속되고, 각 쓰레드는 독립된 메모리 영역인 ‘Stack’을 갖는다. 각 쓰레드는 다른 쓰레드에게 스택 메모리를 공유할 수 없다. 하지만 프로세스의 힙은 그 프로세스에 속한 모든 쓰레드가 공유할 수 있다.

- 스택 영역
    
    함수 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다.
    
    함수 호출 시 할당되며, 함수의 호출이 완료되면 소멸한다.
    
    스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
    
    PUSH로 데이터 저장, POP으로 데이터 인출
    
    매우 빠른 액세스, 지역변수만, 변수를 명시적으로 할당 해제 할 필요 없다.
    
    공간은 CPU에 의해 효율적으로 관리되고 메모리는 단편화되지 않는다.
    
- 힙 영역
    
    사용자가 직접 관리하는 메모리 영역이다.
    
    사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다.
    
    힙 영역은 메모리의 낮은 주소에서 높은 주의 방향으로 할당된다.
    
    상대적으로 느린 액세스, 메모리 크기 제한 없음, 메모리를 관리(변수를 할당하고 해제)해야 한다.
    

### 동시성 vs 병렬성

- 동시성 : 동시에 여러 작업을 수행하는 것. 눈으로 보기에만 동시에 실행되는 것이고, 시분할(Interleaving) 기법을 활용하여 여러 작업을 조금씩 나누서 번갈아가면서 실행하는 것.
- 병렬성 : 실제로 여러 작업을 한 번에 동시에 수행하는 것. 자원(CPU 코어)의 입장에서는 자기 할 일 1개를 하는 것이다. 즉, 병렬성은 자원(CPU코어) 여러 개 일 때 가능하다.

## 코루틴이란

1. **협력형 멀티 태스킹**
2. 동시성 프로그래밍 지원
3. 비동기 처리를 쉽게 도와줌

### 협력형 멀티 태스킹

```kotlin
fun main() {
	...
	val addedValue = plusOne(value)
	...
}

fun plusOne(value: Int) {
	val one = 1
	val addedValue = value + one

	return addedValue
}
```

메인 쓰레드가 `plusOne` 이라는 서브루틴에 진입한다. 코드는 윗줄부터 실행 될 것이고, 아래 코드들을 실행해서 `return` 을 만나면 서브루틴을 호출했던 부분으로 탈출한다. 그리고 진입점과 탈출점 사이에 쓰레드는 블락되어있다. 

**코루틴은 다르다.**

진입점과 탈출점이 여러개가 된다.

```kotlin
fun drawPerson() {
	startCoroutine { // 코루틴 빌더 (실제로 startCoroutine이라는 빌더는 존재X)
		drawHead()
		drawBody()
		drawLegs()
	}
}

suspend fun drawHead() {
	delay(2000)
	...
}

suspend fun drawBody() {
	delay(5000)
	...
}

suspend fun drawLegs() {
	delay(3000)
	...
}
```

1. 쓰레드의 main 함수가 `drawPerson()` 을 호출하면 하나의 코루틴 블럭(함수)이 생성 된다. `drawPersion()` 은 언제든 진입, 탈출할 수 있는 자격이 주어진다함
2. 코루틴 함수가 실행되는 과정에서 suspend 키워드를 가진 함수를 만나면 더이상 아래 코드를 실행하지 않고 멈추고(suspend) 코루틴 block을 탈출한다.
3. 메인 쓰레드의 다른 코드들이 실행된다. 그러나 Head(`drawHead`)는 어디선가 계속 그려지고 있다.
4. 다른 코드들이 실행되다가도, drawHead가 끝이나면 다시 코루틴으로 진입해서 아까 멈춘 부분(`drawHead`) 아래부터 다시 실행된다.

코루틴 함수는 언제든지 나왔다가 다시 들어올 수 있다. 코루틴의 이런 성향은 동시성 프로그래밍과 밀접한 관계가 있다.

**코루틴은 동시성을 지원한다.**

코루틴을 사용하면 쓰레드 하나에서 동시성 프로그래밍이 가능하다.

멀티쓰레드를 이용하는데 CPU가 단 한개라면? CPU가 매번 쓰레드를 점유했다가 놓아주어야 한다. - 컨텍스트 스위칭. 하나의 쓰레드에서 단순히 함수를 왔다갔다 하는 것과는 다르게 비용이 꽤 든다.

> 2,000개 미만의 쓰레드에는 1.5GB 이상의 메모리가 필요하다. 100만 개의 코루틴은 700MB 미만의 메모리가 필요하다. 결론은 코루틴은 매우, 매우 가볍다. - “함수형 코틀린” 마리오 아리아
>